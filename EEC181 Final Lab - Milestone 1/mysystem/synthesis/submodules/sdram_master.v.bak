module sdram_master(
input clk,
input startSig,
output reg doneSig = 0, 
output reg read_n = 1,
output reg write_n = 1,
output reg chipselect,
input waitrequest,
output reg [31:0] address = 0,
output reg [1:0] byteenable,
input readdatavalid,
input signed [15:0] readdata,
output reg [15:0] writedata,
output [3:0] s,
input reset_n
);

reg [3:0] state;
reg [31:0] count, count2, count3;
reg signed [15:0] accumulator,accStore;
reg [12543:0] testData, dataStore;
integer i,k;

// Flags
reg readdone;

wire [7:0] p0, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10,p11;

localparam state0 = 4'd0;
localparam state1 = 4'd1;
localparam state2 = 4'd2; 
localparam state3 = 4'd3;
localparam state4 = 4'd4; 
localparam state5 = 4'd5;
localparam state6 = 4'd6;
localparam state7 = 4'd7;
 
assign s = state[3:0];


initial begin
	state = 4'd0;
	count = 0;
	count2 = 0;
	count3 = 0;
	readdone = 0;
end

always @ (posedge clk) begin

	case(state)
		state0: begin
			doneSig <= 1'b1;
			write_n <= 1'b1;
			read_n <= 1'b1;
			chipselect <= 1'b0;
			byteenable <= 2'b00;
			address <= 0;
			count <= 0;
			count3 <= 0;
			read_n <= 1'b1;
			if(startSig == 0) begin
				state <= state0;
			end
			else begin
				state <= state1;
			end
		end
		
		// get all 784 input data
		state1: begin
			write_n <= 1'b1;
			read_n <= (count < 784) ? 0 : 1;
			chipselect <= 1'b1;
			byteenable <= 2'b11;
			address <= (waitrequest == 0) ? count : address;
			count <= (count < 784 && waitrequest == 0) ? count + 1 : count;
			state <= (count < 784) ? state1 : state2;
		end
		// wait until all image input values are read in
		
		state2: begin
			write_n <= 1'b1;
			read_n <= 1'b1;
			chipselect <= 1'b1;
			if(count2 < 784) begin
				state <= state2;
			end
			else begin
				state <= state3;
			end
		end
		
		// send out 200 signals
		state3: begin
			write_n <= 1'b1;
			read_n <= ((count-784) < 784) ? 0 : 1;
			chipselect <= 1'b1;
			byteenable <= 2'b11;
			address <= (waitrequest == 0) ? count : address;
			count <= ((count-784) < 784 && waitrequest == 0) ? count + 1 : count;
			state <= ((count-784) < 784) ? state4 : state3;
		end
		
		// writes the values into sdram ( potentially could combine with state 3 to increase parallelism )
		state4: begin
			write_n <= 1'b1;
			read_n <= 1'b1;
			chipselect <= 1'b1;
			byteenable <= 2'b11;
			if(count3 % 784 == 0 && count3 != 0) begin
				accStore <= accumulator;
				state <= state5;
			end
			else begin
				state <= state4;
			end
		end
		
		// send out addresses of next values to be read into the array
		state5: begin
			write_n <= 1'b0;
			read_n <= 1'b1;
			chipselect <= 1'b1;
			byteenable <= 2'b11;
			address <= 158780;
			writedata <= accStore;
			if(waitrequest == 0) begin
				state <= state6;
			end
			else begin
				state <= state5;
			end
		end
		
		state6: begin
			write_n <= 1'b0;
			read_n <= 1'b1;
			chipselect <= 1'b1;
			byteenable <= 2'b11;
			address <= 158781;
			writedata <= accStore;
			if(waitrequest == 0) begin
				state <= state6;
			end
			else begin
				state <= state5;
			end
		end
		
		state7: begin
			write_n <= 1'b1;
			read_n <= 1'b1;
			chipselect <= 1'b1;
			state <= state7;
		end
		
		default: begin
			state <= state0;
			read_n <= 1'b1;
			write_n <= 1'b1;
			chipselect <= 1'b0;
			byteenable <= 2'b00;
			doneSig <= 1'b1;
			address <= 0;
		end
	endcase 

end

/*
	Readdatavalid + waitrequest is independent of one another so there is no reason to clump them together
	This always loop simply keeps watching for the readdatavalid signal to be asserted before using the data
	that is found in readdata. Readdata(s) can come in way after you send all your addresses, thus there is a period of time
	you may have to wait before all your data comes through.
	
	Source: Page 3-10 of https://www.altera.com/en_US/pdfs/literature/manual/mnl_avalon_spec_1_3.pdf
*/

//Initial read in of the 1028 values OR start reading 2 values in

always @ (posedge clk) begin
	if ((readdatavalid == 1'b1) && (count2 < 784)) begin
		testData <= (testData << 16) + readdata[15:0];
		count2 <= count2 + 1;
	end
	else if ((readdatavalid == 1'b1) && (count2 >= 784)) begin
		if (count3 % 784 == 0 && count3 != 0) begin
			if (dataStore[12543:12528] == 1) begin
				accumulator <= readdata;
			end
			else begin
				accumulator <= 0;
			end
			testData[0:12528] <= dataStore[0:12528];
		end
		else if(testData[15:0] == 16'd1) begin
			accumulator <= accumulator + readdata;
		end
		dataStore <= (dataStore << 16) + testData[0:15];
		testData <= testData >> 16;
		count3 <= count3 + 1;
	end
	else if (count2 < 784) begin
		count2 <= count2;
	end
	else if (count2 >=784) begin
		count3 <= count3;
	end
end

endmodule