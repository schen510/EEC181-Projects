module sdram_master(
input clk,
input startSig,
output reg doneSig, 
output reg read_n = 1,
output reg write_n = 1,
output reg chipselect,
input waitrequest,
output reg [31:0] address = 0,
output reg [1:0] byteenable,
input readdatavalid,
input [15:0] readdata,
output reg [15:0] writedata,
output [3:0] s,
input reset_n
);

reg [2:0] state = 3'd0;
reg [3:0] count = 4'd0;
 
//The lowest maximum possible is 0 and highest minimum is all 16 bits asserted
reg [15:0] max = 16'd0;
reg [15:0] min = 16'hffff;

localparam state0 = 3'd0;
localparam state1 = 3'd1;
localparam state2 = 3'd2; 
localparam state3 = 3'd3;
localparam state4 = 3'd4; 
localparam state5 = 3'd5; 
localparam BASEADDRESS = 32'd0;
localparam MINADD = 32'd1;
localparam MAXADD = 32'd2;

assign s = {2'b00,waitrequest,readdatavalid};

always @ (posedge clk) begin

	case(state)
		/*
			state 0 waits for a start signal -- the c code will put a 1 at the 11th spot
			once we grab that then we can start the check for the minimum and maximum values
			by moving to state 1
		*/
		
		state0: begin
			if(~startSig) begin
				state <= state0;
			end
			else begin
				state <= state1;
			end
			/*
			write_n <= 1'b1;
			read_n <= 1'b0;
			chipselect <= 1'b1;
			address <= 32'd20 + BASEADDRESS;
			count <= 5'd0;
			writedata <= 16'd0;
			if ((waitrequest == 1'b0) && (readdatavalid == 1'b1) && (readdata == 16'd1)) begin
				state <= state1;
			end
			else begin
				state <= state0;
			end
			*/
		end
		
		/*
			state 1 is the state to determine whether we write or read (the other idea is that you have a read and write state)
			if this doesn't work then scrap it and change state 1 to purely read and as follows
			it sends out the read/write/chipselect stuff and then sends it to state 2 if the count is less than 10 (10 would rep. the 11th value)
			at the 11th value you want to move to writing the min + max values to their corresponding addresses since
			you know the minimum and maximum at this point in time (move to state3)
		*/
		state1: begin
			if (count < 10) begin
				write_n <= 1'b1;
				read_n <= 1'b0;
				chipselect <= 1'b1;
				address <= (count*2) + BASEADDRESS;
				writedata <= 16'd0;
				byteenable <= 2'b00;
				state <= state2;
			end
			else begin
				state <= state3;
			end
		end
		/*
			state2 waits in this state until we successfully read the value at the address location specified earlier in state1
			if it is not successful, then it waits in this state until it reads a valid data value from the SDRAM
		*/
		state2: begin
			if ((waitrequest == 1'b0) && (readdatavalid == 1'b1)) begin
				if(readdata > max) begin
					max <= readdata;
				end
				if(readdata < min) begin
					min <= readdata;
				end
				count <= count + 1;
				state <= state1;
			end
				state <= state2;
		end
		/*
			state3 writes the minimum value to the MINADD which contains the address of where the minimum value should begin
			if it is successful, then it will transition to writing the maximum value, otherwise it stays in this state
		*/
		state3: begin
			write_n <= 1'b0;
			read_n <= 1'b1;
			chipselect <= 1'b1;
			byteenable <= 2'b11;
			address <= MINADD;
			writedata <= min;
			if (waitrequest == 1'b0) begin
				state <= state4;
			end
			else begin
				state <= state3;
			end
		end
		
		state4: begin
			write_n <= 1'b0;
			read_n <= 1'b1;
			chipselect <= 1'b1;
			byteenable <= 2'b11;
			address <= MAXADD;
			writedata <= max;
			if (waitrequest == 1'b0) begin
				state <= state5;
			end
			else begin
				state <= state4;
			end
		end
		
		state5: begin
			doneSig <= 1'b0;
			state <= state0;
		end
		
		default: begin
			state <= state0;
			read_n <= 1'b1;
			write_n <= 1'b1;
			chipselect <= 1'b0;
			byteenable <= 2'b00;
			address <= 0;
		end
	endcase 
end

endmodule